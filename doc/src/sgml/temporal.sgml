<!-- doc/src/sgml/temporal.sgml -->

 <chapter id="temporal-tables">
  <title>Temporal Tables</title>

  <indexterm zone="temporal-tables">
   <primary>temporal</primary>
  </indexterm>

  <para>
   Temporal tables allow users to track different dimensions of 
   history. Application time tracks the history of a thing out in the 
   world, and system time tracks the history of the database itself. This 
   chapter describes how to express and manage such histories in temporal 
   tables.
  </para>

 <sect1 id="application-time">
  <title>Application Time</title>

   <indexterm zone="application-time">
    <primary>application time</primary>
   </indexterm>

   <para>
    <firstterm>Application time</firstterm> refers to a history of the 
    entity described by a table. In a typical non-temporal table, there is 
    single row for each entity. In a temporal table, an entity may have 
    multiple rows, as long as those rows describe non-overlapping periods 
    from its history. Application time requires each row to have a start 
    and end time, expressing when the row is true.
   </para>

   <para>
    Records in a temporal table can be plotted on a timeline, as in 
    <xref linkend="temporal-entities-figure"/>. Here we show three records 
    describing two products. Each record is a tuple with three attributes: 
    the id, the price, and the application time. So product 5 was first 
    offered for $5 starting January 1, 2020, but then became $8 starting 
    January 1, 2022. Its second record has no specified end time, 
    indicating that it is true indefinitely, or for all future time. The 
    last record shows that product 6 was introduced January 1, 2021 for $9, 
    then canceled January 1, 2024.
   </para>

   <figure id="temporal-entities-figure">
    <title>Application Time Example</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/temporal-entities.svg" format="SVG" width="100%"/>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    In a table, these records would be:
<programlisting>
 id | price |        valid_at
----+-------+-------------------------
  5 |     5 | [2020-01-01,2023-01-01)
  5 |     8 | [2023-01-01,)
  6 |     9 | [2021-01-01,2024-01-01)
</programlisting>
   </para>

   <para>
    We show the application time using rangetype notation, because it 
    is stored as a single column (either a range or multirange). By 
    convention ranges include their start point but exclude their end 
    point. That way two adjacent ranges cover all points without 
    overlapping.
   </para>

   <para>
    In principle, a table with application-time ranges/multiranges is 
    equivalent to a table that stores application-time "instants": one for 
    each second, millisecond, nanosecond, or whatever finest granularity is 
    available. But such a table would contain far too many rows, so 
    ranges/multiranges offer an optimization to represent the same 
    information in a compact form. In addition, ranges and multiranges 
    offer a more convenient interface for typical temporal operations, 
    where records change infrequently enough that separate "versions" 
    persist for extended periods of time.
   </para>

  <sect2 id="application-time-primary-keys">
   <title>Temporal Primary Keys and Unique Constraints</title>

   <para>
    A table with application time has a different concept of entity 
    integrity than a non-temporal table. Temporal entity integrity can be 
    enforced with a temporal primary key. A regular primary key has at 
    least one element, all elements are <literal>NOT NULL</literal>, and 
    the combined value of all elements is unique. A temporal primary key 
    also has at least one such element, but in addition it has a final 
    element that is a rangetype or multirangetype that shows when it was 
    true. The regular parts of the key must be unique for any moment in 
    time, but non-unique records are allowed if their application time does 
    not overlap.
   </para>

   <para>
    The syntax to create a temporal primary key is as follows:

<programlisting>
ALTER TABLE products
  ADD CONSTRAINT products_pkey
  PRIMARY KEY (id, valid_at WITHOUT OVERLAPS);
</programlisting>

    In this example, <literal>id</literal> is the non-temporal part of 
    the key, and <literal>valid_at</literal> is a range column containing 
    the application time. You can also create the primary key as part of 
    the <link linkend="sql-createtable"><literal>CREATE 
    TABLE</literal></link> command.
   </para>

   <para>
    The <literal>WITHOUT OVERLAPS</literal> column must be <literal>NOT 
    NULL</literal> (like the other parts of the key). In addition it may 
    not contain empty values: a rangetype of <literal>'empty'</literal> or 
    a multirange of <literal>{}</literal>. An empty application time would 
    have no meaning.
   </para>

   <para>
    It is also possible to create a temporal unique constraint that is 
    not a primary key. The syntax is similar:

<programlisting>
ALTER TABLE products
  ADD CONSTRAINT products_id_valid_at_key
  UNIQUE (id, valid_at WITHOUT OVERLAPS);
</programlisting>

    You can also create the unique constraint as part of the <link 
linkend="sql-createtable"><literal>CREATE TABLE</literal></link> 
command.
   </para>

   <para>
    Temporal unique constraints also forbid empty ranges/multiranges 
    for their application time, although that column is permitted to be 
    null (like other elements of the key).
   </para>

   <para>
    Temporal primary keys and unique constraints are backed by
    <link linkend="gist">GiST indexes</link> rather than B-Tree indexes. In 
    practice, creating a temporal primary key or exclusion constraint 
    requires installing the <xref linkend="btree-gist"/> extension, so that 
    the database has opclasses for the non-temporal parts of the key.
   </para>

   <para>
    Temporal primary keys and unique constraints have the same behavior 
    as <xref linkend="ddl-constraints-exclusion"/>, where each regular key 
    part is compared with equality, and the application time is compared 
    with overlaps, for example <literal>EXCLUDE USING gist (id WITH =, 
    valid_at WITH &amp;&amp;)</literal>. The only difference is that they 
    also forbid an empty application time.
   </para>
  </sect2>

  <sect2 id="application-time-foreign-keys">
   <title>Temporal Foreign Keys</title>

   <para>
    A temporal foreign key is a reference from one application-time 
    table to another application-time table. Just as a non-temporal 
    reference requires a referenced key to exist, so a temporal reference 
    requires a referenced key to exist, but during whatever history the 
    reference exists. So if the <literal>products</literal> table is 
    referenced by a <literal>variants</literal> table, and a variant of 
    product 5 has an application-time of 
    <literal>[2020-01-01,2026-01-01)</literal>, then product 5 must exist 
    throughout that period.
   </para>

   <figure id="temporal-references-figure">
    <title>Temporal Foreign Key Example</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/temporal-references.svg" format="SVG" width="100%"/>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    <xref linkend="temporal-references-figure"/> plots product 5 (in 
    green) and two variants referencing it (in yellow) on the same 
    timeline. Each variant tuple is shown with its id, a product id, a 
    name, and an application-time. So variant 8 (Medium) was introduced 
    first, then variant 9 (XXL). Both satisfy the foreign key constraint, 
    because the referenced product exists throughout their entire history.
   </para>

   <para>
    Note that a temporal reference need not be fulfilled by a single 
    row in the referenced table. Product 5 had a price change in the middle 
    of variant 8's history, but the reference is still valid. The 
    combination of all matching rows is used to test whether the referenced 
    history contains the referencing row.
   </para>

   <para>
    The syntax to declare a temporal foreign key is:

<programlisting>
ALTER TABLE variants
  ADD CONSTRAINT variants_id_valid_at_fkey
  FOREIGN KEY (id, PERIOD valid_at)
  REFERENCES products (id, PERIOD valid_at);
</programlisting>

    Note that the keyword <literal>PERIOD</literal> must be used for application-time column
    in both the referencing and referenced table.
   </para>

   <para>
    A temporal primary key or unique constraint matching the referenced columns
    must exist on the referenced table.
   </para>

   <para>
    <productname>PostgreSQL</productname> supports <literal>NO ACTION</literal> temporal foreign keys,
    but not <literal>RESTRICT</literal>, <literal>CASCADE</literal>, <literal>SET NULL</literal>,
    or <literal>SET DEFAULT</literal>.
   </para>
  </sect2>

  <sect2 id="application-time-update-delete">
   <title>Temporal Update and Delete</title>

   <para>
    <productname>PostgreSQL</productname> does not yet support special 
    syntax to update and delete portions of history in temporal tables.
   </para>
  </sect2>
  </sect1>

  <sect1 id="system-time">
   <title>System Time</title>

   <indexterm zone="system-time">
    <primary>system time</primary>
   </indexterm>

   <para>
    <firstterm>System time</firstterm> refers to the history of the 
    database table, not the entity it describes. It captures when each row 
    was inserted/updated/deleted.
   </para>

   <para>
    Like application time, system time has two timestamps: a start time 
    and an end time. The start time shows when the row was added (either by 
    an insert or an update), and the end time shows when it stopped being 
    asserted (either by an update or a delete). The database maintains 
    these values automatically; the user is not able to set them.
   </para>

   <para>
    If a query filters rows for those with a system time containing a 
    given moment in time, the result is equivalent to a non-temporal table 
    from that moment. In that way, you can ask what the table asserted at 
    different times in the past. This is useful for auditing, compliance, 
    and debugging.
   </para>

   <para>
    <productname>PostgreSQL</productname> does not currently support 
    system time, but there are several extensions that provide its 
    functionality. See
    <ulink url="https://wiki.postgresql.org/wiki/SQL2011Temporal">the SQL:2011 
    Temporal wiki page</ulink> for possibilities.
   </para>
  </sect1>

 </chapter>
