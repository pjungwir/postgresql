<!-- doc/src/sgml/temporal.sgml -->

 <chapter id="temporal-tables">
  <title>Temporal Tables</title>

  <indexterm zone="temporal-tables">
   <primary>temporal</primary>
  </indexterm>

  <para>
   Temporal tables allow users to track different dimensions of 
   history. Application time tracks the history of a thing out in the 
   world, and system time tracks the history of the database itself. This 
   chapter describes how to express and manage such histories in temporal 
   tables.
  </para>

 <sect1 id="periods">
  <title>Periods</title>

  <indexterm zone="periods">
   <primary>periods</primary>
  </indexterm>

  <para>
   A <firstterm>period</firstterm> is metadata attached to a table 
   uniting two columns, a start time and end time, into one range-like 
   construct. Periods are used to represent <link 
   linkend="system-time">system time</link> and <link 
   linkend="application-time">application time</link>. A system-time 
   period must be named <literal>system_time</literal>, and an 
   application-time period can be named anything else. Their names must 
   not conflict with column names from the same table.
  </para>

  <para>
   Periods are referenced in several temporal operations described in 
   this chapter: temporal primary keys, unique constraints, foreign keys, 
   update commands, and delete commands. 
   <productname>PostgreSQL</productname> does not yet support periods. 
   Commands that accept periods instead accept columns with a
   <link linkend="rangetypes-builtin">rangetype or multirangetype</link>. 
   Support for periods is planned for the future.
  </para>
 </sect1>

 <sect1 id="application-time">
  <title>Application Time</title>

   <indexterm zone="application-time">
    <primary>application time</primary>
   </indexterm>

   <para>
    <firstterm>Application time</firstterm> refers to a history of the 
    entity described by a table. In a typical non-temporal table, there is 
    single row for each entity. In a temporal table, an entity may have 
    multiple rows, as long as those rows describe non-overlapping periods 
    from its history. Application time requires each row to have a start 
    and end time, expressing when the row is true.
   </para>

   <para>
    Records in a temporal table can be plotted on a timeline, as in 
    <xref linkend="temporal-entities-figure"/>. Here we show three records 
    describing two products. Each record is a tuple with three attributes: 
    the id, the price, and the application time. So product 5 was first 
    offered for $5 starting January 1, 2020, but then became $8 starting 
    January 1, 2022. Its second record has no specified end time, 
    indicating that it is true indefinitely, or for all future time. The 
    last record shows that product 6 was introduced January 1, 2021 for $9, 
    then canceled January 1, 2024.
   </para>

   <figure id="temporal-entities-figure">
    <title>Application Time Example</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/temporal-entities.svg" format="SVG" width="100%"/>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    In a table, these records would be:
<programlisting>
 id | price |        valid_at
----+-------+-------------------------
  5 |     5 | [2020-01-01,2023-01-01)
  5 |     8 | [2023-01-01,)
  6 |     9 | [2021-01-01,2024-01-01)
</programlisting>
   </para>

   <para>
    We show the application time using rangetype notation, because it 
    is stored as a single column (either a range or multirange). By 
    convention ranges include their start point but exclude their end 
    point. That way two adjacent ranges cover all points without 
    overlapping.
   </para>

   <para>
    In principle, a table with application-time ranges/multiranges is 
    equivalent to a table that stores application-time "instants": one for 
    each second, millisecond, nanosecond, or whatever finest granularity is 
    available. But such a table would contain far too many rows, so 
    ranges/multiranges offer an optimization to represent the same 
    information in a compact form. In addition, ranges and multiranges 
    offer a more convenient interface for typical temporal operations, 
    where records change infrequently enough that separate "versions" 
    persist for extended periods of time.
   </para>

  <sect2 id="application-time-primary-keys">
   <title>Temporal Primary Keys and Unique Constraints</title>

   <para>
    A table with application time has a different concept of entity 
    integrity than a non-temporal table. Temporal entity integrity can be 
    enforced with a temporal primary key. A regular primary key has at 
    least one element, all elements are <literal>NOT NULL</literal>, and 
    the combined value of all elements is unique. A temporal primary key 
    also has at least one such element, but in addition it has a final 
    element that is a rangetype or multirangetype that shows when it was 
    true. The regular parts of the key must be unique for any moment in 
    time, but non-unique records are allowed if their application time does 
    not overlap.
   </para>

   <para>
    The syntax to create a temporal primary key is as follows:

<programlisting>
ALTER TABLE products
  ADD CONSTRAINT products_pkey
  PRIMARY KEY (id, valid_at WITHOUT OVERLAPS);
</programlisting>

    In this example, <literal>id</literal> is the non-temporal part of 
    the key, and <literal>valid_at</literal> is a range column containing 
    the application time. You can also create the primary key as part of 
    the <link linkend="sql-createtable"><literal>CREATE 
    TABLE</literal></link> command.
   </para>

   <para>
    The <literal>WITHOUT OVERLAPS</literal> column must be <literal>NOT 
    NULL</literal> (like the other parts of the key). In addition it may 
    not contain empty values: a rangetype of <literal>'empty'</literal> or 
    a multirange of <literal>{}</literal>. An empty application time would 
    have no meaning.
   </para>

   <para>
    It is also possible to create a temporal unique constraint that is 
    not a primary key. The syntax is similar:

<programlisting>
ALTER TABLE products
  ADD CONSTRAINT products_id_valid_at_key
  UNIQUE (id, valid_at WITHOUT OVERLAPS);
</programlisting>

    You can also create the unique constraint as part of the <link 
linkend="sql-createtable"><literal>CREATE TABLE</literal></link> 
command.
   </para>

   <para>
    Temporal unique constraints also forbid empty ranges/multiranges 
    for their application time, although that column is permitted to be 
    null (like other elements of the key).
   </para>

   <para>
    Temporal primary keys and unique constraints are backed by
    <link linkend="gist">GiST indexes</link> rather than B-Tree indexes. In 
    practice, creating a temporal primary key or exclusion constraint 
    requires installing the <xref linkend="btree-gist"/> extension, so that 
    the database has opclasses for the non-temporal parts of the key.
   </para>

   <para>
    Temporal primary keys and unique constraints have the same behavior 
    as <xref linkend="ddl-constraints-exclusion"/>, where each regular key 
    part is compared with equality, and the application time is compared 
    with overlaps, for example <literal>EXCLUDE USING gist (id WITH =, 
    valid_at WITH &amp;&amp;)</literal>. The only difference is that they 
    also forbid an empty application time.
   </para>
  </sect2>

  <sect2 id="application-time-foreign-keys">
   <title>Temporal Foreign Keys</title>

   <para>
    A temporal foreign key is a reference from one application-time 
    table to another application-time table. Just as a non-temporal 
    reference requires a referenced key to exist, so a temporal reference 
    requires a referenced key to exist, but during whatever history the 
    reference exists. So if the <literal>products</literal> table is 
    referenced by a <literal>variants</literal> table, and a variant of 
    product 5 has an application-time of 
    <literal>[2020-01-01,2026-01-01)</literal>, then product 5 must exist 
    throughout that period.
   </para>

   <figure id="temporal-references-figure">
    <title>Temporal Foreign Key Example</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/temporal-references.svg" format="SVG" width="100%"/>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    <xref linkend="temporal-references-figure"/> plots product 5 (in 
    green) and two variants referencing it (in yellow) on the same 
    timeline. Each variant tuple is shown with its id, a product id, a 
    name, and an application-time. So variant 8 (Medium) was introduced 
    first, then variant 9 (XXL). Both satisfy the foreign key constraint, 
    because the referenced product exists throughout their entire history.
   </para>

   <para>
    Note that a temporal reference need not be fulfilled by a single 
    row in the referenced table. Product 5 had a price change in the middle 
    of variant 8's history, but the reference is still valid. The 
    combination of all matching rows is used to test whether the referenced 
    history contains the referencing row.
   </para>

   <para>
    The syntax to declare a temporal foreign key is:

<programlisting>
ALTER TABLE variants
  ADD CONSTRAINT variants_id_valid_at_fkey
  FOREIGN KEY (id, PERIOD valid_at)
  REFERENCES products (id, PERIOD valid_at);
</programlisting>

    Note that the keyword <literal>PERIOD</literal> must be used for application-time column
    in both the referencing and referenced table.
   </para>

   <para>
    A temporal primary key or unique constraint matching the referenced columns
    must exist on the referenced table.
   </para>

   <para>
    <productname>PostgreSQL</productname> supports <literal>NO ACTION</literal> temporal foreign keys,
    but not <literal>RESTRICT</literal>, <literal>CASCADE</literal>, <literal>SET NULL</literal>,
    or <literal>SET DEFAULT</literal>.
   </para>
  </sect2>

  <sect2 id="application-time-update-delete">
   <title>Temporal Update and Delete</title>

   <para>
    Special syntax is available to update and delete from temporal 
    tables. (No extra syntax is required to insert into them: the user just 
    provides the application time like any other attribute.) When updating 
    or deleting, the user can target a specific portion of history. Only 
    rows overlapping that history are affected, and within those rows only 
    the targeted history is changed. If a row contains more history beyond 
    what is targeted, its application time is reduced to fit within the 
    targeted interval, and new rows are inserted to preserve the history 
    that was not targeted.
   </para>

   <para>
    The syntax for a temporal update is:

<programlisting>
UPDATE products
  FOR PORTION OF valid_at FROM '2023-09-01' TO '2025-03-01'
  AS p
  SET price = 12
  WHERE id = 5;
</programlisting>

    Using the example table introduced already, this command will 
    update the second record for product 5. It will set the price to 12 and 
    the application time to <literal>[2023-09-01,2025-03-01)</literal>. 
    Then, since the row's application time was originally 
    <literal>[2022-01-01,)</literal>, the command must insert two 
    <glossterm linkend="glossary-temporal-leftovers">temporal 
    leftovers</glossterm>: one for history before September 1, 2023, and 
    another for history since March 1, 2025. After the update, the table 
    has three rows for product 5:

<programlisting>
 id | price |        valid_at
----+-------+-------------------------
  5 |     5 | [2020-01-01,2022-01-01)
  5 |     8 | [2022-01-01,2023-09-01)
  5 |    12 | [2023-09-01,2025-03-01)
  5 |     8 | [2025-03-01,)
</programlisting>

    The new history could be plotted as in <xref linkend="temporal-update-figure"/>.
   </para>

   <figure id="temporal-update-figure">
    <title>Temporal Update Example</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/temporal-update.svg" format="SVG" width="100%"/>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    Similarly, a specific portion of history may be targeted when 
    deleting rows from a table. In that case, the original rows are 
    removed, but new
    <glossterm linkend="glossary-temporal-leftovers">temporal leftovers</glossterm> 
    are inserted to preserve the untouched history. The syntax for a 
    temporal delete is:

<programlisting>
DELETE FROM products
  FOR PORTION OF valid_at FROM '2021-08-01' TO '2023-09-01'
  AS p
WHERE id = 5;
</programlisting>

    Continuing the example, this command would delete two records. The 
    first record would yield a single temporal leftover, and the second 
    would be deleted entirely. The rows for product 5 would now be:

<programlisting>
 id | price |        valid_at
----+-------+-------------------------
  5 |     5 | [2020-01-01,2021-08-01)
  5 |    12 | [2023-09-01,2025-03-01)
  5 |     8 | [2025-03-01,)
</programlisting>

    The new history could be plotted as in <xref linkend="temporal-delete-figure"/>.
   </para>

   <figure id="temporal-delete-figure">
    <title>Temporal Delete Example</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/temporal-delete.svg" format="SVG" width="100%"/>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    Instead of using the <literal>FROM ... TO ...</literal> syntax, 
    temporal update/delete commands can also give the targeted 
    range/multirange directly, inside parentheses. For example: 
    <literal>DELETE FROM products FOR PORTION OF valid_at ('[2028-01-01,)') ...</literal>.
    This syntax is required when application time is stored 
    in a multirange column.
   </para>

   <para>
    When application time is stored in a rangetype column, zero, one or 
    two temporal leftovers are produced by each row that is 
    updated/deleted. With a multirange column, only zero or one temporal 
    leftover is produced. The leftover bounds are computed using 
    <literal>range_minus_multi</literal> and 
    <literal>multirange_minus_multi</literal>
    (see <xref linkend="functions-range"/>).
   </para>

   <para>
    The bounds given to <literal>FOR PORTION OF</literal> must be 
    constant. Functions like <literal>NOW()</literal> are allowed, but 
    column references are not.
   </para>

   <para>
    When temporal leftovers are inserted, all <literal>INSERT</literal> 
    triggers are fired, but permission checks for inserting rows are 
    skipped.
   </para>
  </sect2>
  </sect1>

  <sect1 id="system-time">
   <title>System Time</title>

   <indexterm zone="system-time">
    <primary>system time</primary>
   </indexterm>

   <para>
    <firstterm>System time</firstterm> refers to the history of the 
    database table, not the entity it describes. It captures when each row 
    was inserted/updated/deleted.
   </para>

   <para>
    Like application time, system time has two timestamps: a start time 
    and an end time. The start time shows when the row was added (either by 
    an insert or an update), and the end time shows when it stopped being 
    asserted (either by an update or a delete). The database maintains 
    these values automatically; the user is not able to set them.
   </para>

   <para>
    If a query filters rows for those with a system time containing a 
    given moment in time, the result is equivalent to a non-temporal table 
    from that moment. In that way, you can ask what the table asserted at 
    different times in the past. This is useful for auditing, compliance, 
    and debugging.
   </para>

   <para>
    <productname>PostgreSQL</productname> does not currently support 
    system time, but there are several extensions that provide its 
    functionality. See
    <ulink url="https://wiki.postgresql.org/wiki/SQL2011Temporal">the SQL:2011 
    Temporal wiki page</ulink> for possibilities.
   </para>
  </sect1>

 </chapter>
