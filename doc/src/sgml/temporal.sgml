<!-- doc/src/sgml/temporal.sgml -->

 <chapter id="temporal-tables">
  <title>Temporal Tables</title>

  <indexterm zone="temporal-tables">
   <primary>temporal</primary>
  </indexterm>

  <para>
   Temporal tables allow users to track different dimensions of history.
   Application time tracks the history of a thing out in the world,
   and system time tracks the history of the database itself.
   This chapter describes how to express and manage such histories in temporal tables.
  </para>

 <sect1 id="application-time">
  <title>Application Time</title>

   <indexterm zone="application-time">
    <primary>application time</primary>
   </indexterm>

   <para>
    <firstterm>Application time</firstterm> refers to a history of the entity described by a table.
    In a typical non-temporal table, there is single row for each entity.
    In a temporal table, an entity may have multiple rows, as long as those rows describe non-overlapping periods from its history.
    Application time requires each row to have a start and end time, expressing when the row is true.
   </para>

   <para>
    Records in a temporal table can be plotted on a timeline, as in <xref linkend="temporal-entities-figure"/>.
    Here we show three records describing two products.
    Each record is a tuple with three attributes: the id, the price, and the application time.
    So product 5 was first offered for $5 starting January 1, 2020,
    but then became $8 starting January 1, 2023.
    Its second record has no specified end time, indicating that it is true indefinitely, or for all future time.
    The last record shows that product 6 was introduced January 1, 2021 for $9, then canceled January 1, 2024.
   </para>

   <figure id="temporal-entities-figure">
    <title>Application Time Example</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/temporal-entities.svg" format="SVG" width="100%"/>
     </imageobject>
    </mediaobject>
   </figure>

   <para>
    In a table, these records would be:
<programlisting>
 id | price |        valid_at
----+-------+-------------------------
  5 |     5 | [2020-01-01,2023-01-01)
  5 |     8 | [2023-01-01,)
  6 |     9 | [2021-01-01,2024-01-01)
</programlisting>
   </para>

   <para>
    We show the application time using <xref linkend="rangetypes-builtin"/> notation, because it is stored as a single column (either a range or multirange). By convention ranges include their start point but exclude their end point. That way two adjacent ranges cover all points without overlapping.
   </para>

   <para>
    In principle, a table with application-time ranges/multiranges is equivalent
    to a table that stores application-time "instants":
    one for each second, millisecond, nanosecond, or whatever finest granularity is available.
    But such a table would contain far too many rows,
    so ranges/multiranges offer an optimization to represent the same information in a compact form.
    In addition, ranges and multiranges offer a more convenient interface for typical temporal operations,
    where records change infrequently enough that separate "versions" persist for extended periods of time.
   </para>

  <sect2 id="application-time-primary-keys">
   <title>Temporal Primary Keys and Unique Constraints</title>

   <para>
    A table with application time has a different concept of entity integrity than a non-temporal table.
    Temporal entity integrity can be enforced with a temporal primary key.
    A regular primary key has at least one element, all elements are <literal>NOT NULL</literal>,
    and the combined value of all elements is unique.
    A temporal primary key also has at least one such element,
    but in addition it has a final element that is a rangetype or multirangetype that shows when it was true.
    The regular parts of the key must be unique for any moment in time,
    but non-unique records are allowed if their application time does not overlap.
   </para>

   <para>
    The syntax to create a temporal primary key is as follows:

<programlisting>
ALTER TABLE products
  ADD CONSTRAINT products_pkey
  PRIMARY KEY (id, valid_at WITHOUT OVERLAPS);
</programlisting>

    In this example, <literal>id</literal> is the non-temporal part of the key,
    and <literal>valid_at</literal> is a range column containing the application time.
    You can also create the primary key as part of the <literal>CREATE TABLE</literal> command.
   </para>

   <para>
    The <literal>WITHOUT OVERLAPS</literal> column must be <literal>NOT NULL</literal>
    (like the other parts of the key).
    In addition it may not contain empty values: a rangetype of <literal>'empty'</literal>
    or a multirange of <literal>{}</literal>.
    An empty application time would have no meaning.
   </para>

   <para>
    It is also possible to create a temporal unique constraint that is not a primary key.
    The syntax is similar:

<programlisting>
ALTER TABLE products
  ADD CONSTRAINT products_id_valid_at_key
  UNIQUE (id, valid_at WITHOUT OVERLAPS);
</programlisting>

    You can also create the unique constraint as part of the <literal>CREATE TABLE</literal> command.
   </para>

   <para>
    Temporal unique constraints also forbid empty ranges/multiranges for their application time,
    although that column is permitted to be null (like other elements of the key).
   </para>

   <para>
    Temporal primary keys and unique constraints are backed by <xref linkend="gist"/>
    rather than B-Tree indexes. In practice, creating a temporal primary key or exclusion constraint
    requires installing the <xref linkend="btree-gist"/> extension,
    so that the database has opclasses for the non-temporal parts of the key.
   </para>

   <para>
    Temporal primary keys and unique constraints have the same behavior as <xref linkend="ddl-constraints-exclusion"/>, where each regular key part is compared with equality, and the application time is compared with overlaps, for example <literal>EXCLUDE USING gist (id WITH =, valid_at WITH &amp;&amp;)</literal>. The only difference is that they also forbid an empty application time.
   </para>
  </sect2>

  <sect2 id="application-time-foreign-keys">
   <title>Temporal foreign keys</title>

   <para>
    A temporal foreign key is a reference from one application-time table to another application-time table. Just as a non-temporal reference requires a referenced key to exist,
    so a temporal reference requires a referenced key to exist, but during whatever history the reference exists. So if the <literal>products</literal> table is referenced by a <literal>variants</literal> table, and a variant of product 5 has an application-time of <literal>[2020-01-01,2026-01-01)</literal>, then product 5 must exist throughout that period.
   </para>

   <para>
    A temporal reference need not be fulfilled by a single row in the referenced table.
    If product 5 has been updated at various times, its history will be spread across several rows.
    But a reference is still valid if the combination of those rows contains the referencing row's application time.
   </para>

   <para>
    The syntax to declare a temporal foreign key is:

<programlisting>
ALTER TABLE variants
  ADD CONSTRAINT variants_id_valid_at_fkey
  FOREIGN KEY (id, PERIOD valid_at)
  REFERENCES products (id, PERIOD valid_at);
</programlisting>

    Note that the keyword <literal>PERIOD</literal> must be used for application-time column
    in both the referencing and referenced table.
   </para>

   <para>
    A temporal primary key or unique constraint matching the referenced columns
    must exist on the referenced table.
   </para>

   <para>
    <productname>PostgreSQL</productname> supports <literal>NO ACTION</literal> temporal foreign keys,
    but not <literal>RESTRICT</literal>, <literal>CASCADE</literal>, <literal>SET NULL</literal>,
    or <literal>SET DEFAULT</literal>.
   </para>
  </sect2>

  <sect2 id="application-time-update-delete">
   <title>Temporal update and delete</title>

   <para>
    <productname>PostgreSQL</productname> does not yet support special syntax to update and delete portions of history in temporal tables.
   </para>
  </sect2>
  </sect1>

  <sect1 id="system-time">
   <title>System Time</title>

   <indexterm zone="system-time">
    <primary>system time</primary>
   </indexterm>

   <para>
    <firstterm>System time</firstterm> refers to the history of the database table, not the entity it describes. It captures when each row was inserted/updated/deleted.
   </para>

   <para>
    Like application time, system time has two timestamps: a start time and an end time. The start time shows when the row was added (either by an insert or an update), and the end time shows when it stopped being asserted (either by an update or a delete). <productname>PostgreSQL</productname> maintains these values automatically; the user is not able to set them.
   </para>

   <para>
    If a query filters rows for those with a system time containing a given moment in time,
    the result is equivalent to a non-temporal table from that moment.
    In that way, you can ask what the table asserted at different times in the past.
    This is useful for auditing, compliance, and debugging.
   </para>

   <para>
    <productname>PostgreSQL</productname> does not currently support system time, but there are several extensions that provide its functionality.
    See <ulink url="https://wiki.postgresql.org/wiki/TODO">the Temporal Tables wiki page</ulink> for possibilities.
   </para>
  </sect1>

 </chapter>
