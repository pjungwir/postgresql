-- Tests for UPDATE/DELETE FOR PORTION OF
SET datestyle TO ISO, YMD;
-- Works on non-PK columns
CREATE TABLE for_portion_of_test (
  id int4range,
  valid_at daterange,
  name text NOT NULL
);
INSERT INTO for_portion_of_test (id, valid_at, name) VALUES
  ('[1,2)', '[2018-01-02,2020-01-01)', 'one');
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-01-15' TO '2019-01-01'
  SET name = 'one^1';
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2019-01-15' TO '2019-01-20';
-- With a table alias with AS
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2019-02-01' TO '2019-02-03' AS t
  SET name = 'one^2';
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2019-02-03' TO '2019-02-04' AS t;
-- With a table alias without AS
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2019-02-04' TO '2019-02-05' t
  SET name = 'one^3';
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2019-02-05' TO '2019-02-06' t;
-- UPDATE with FROM
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2019-03-01' to '2019-03-02'
  SET name = 'one^4'
  FROM (SELECT '[1,2)'::int4range) AS t2(id)
  WHERE for_portion_of_test.id = t2.id;
-- DELETE with USING
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2019-03-02' TO '2019-03-03'
  USING (SELECT '[1,2)'::int4range) AS t2(id)
  WHERE for_portion_of_test.id = t2.id;
SELECT * FROM for_portion_of_test ORDER BY id, valid_at;
  id   |        valid_at         | name  
-------+-------------------------+-------
 [1,2) | [2018-01-02,2018-01-15) | one
 [1,2) | [2018-01-15,2019-01-01) | one^1
 [1,2) | [2019-01-01,2019-01-15) | one
 [1,2) | [2019-01-20,2019-02-01) | one
 [1,2) | [2019-02-01,2019-02-03) | one^2
 [1,2) | [2019-02-04,2019-02-05) | one^3
 [1,2) | [2019-02-06,2019-03-01) | one
 [1,2) | [2019-03-01,2019-03-02) | one^4
 [1,2) | [2019-03-03,2020-01-01) | one
(9 rows)

-- Works on more than one range
DROP TABLE for_portion_of_test;
CREATE TABLE for_portion_of_test (
  id int4range,
  valid1_at daterange,
  valid2_at daterange,
  name text NOT NULL
);
INSERT INTO for_portion_of_test (id, valid1_at, valid2_at, name) VALUES
  ('[1,2)', '[2018-01-02,2018-02-03)', '[2015-01-01,2025-01-01)', 'one');
UPDATE for_portion_of_test
  FOR PORTION OF valid1_at FROM '2018-01-15' TO NULL
  SET name = 'foo';
  SELECT * FROM for_portion_of_test ORDER BY id, valid1_at, valid2_at;
  id   |        valid1_at        |        valid2_at        | name 
-------+-------------------------+-------------------------+------
 [1,2) | [2018-01-02,2018-01-15) | [2015-01-01,2025-01-01) | one
 [1,2) | [2018-01-15,2018-02-03) | [2015-01-01,2025-01-01) | foo
(2 rows)

UPDATE for_portion_of_test
  FOR PORTION OF valid2_at FROM '2018-01-15' TO NULL
  SET name = 'bar';
  SELECT * FROM for_portion_of_test ORDER BY id, valid1_at, valid2_at;
  id   |        valid1_at        |        valid2_at        | name 
-------+-------------------------+-------------------------+------
 [1,2) | [2018-01-02,2018-01-15) | [2015-01-01,2018-01-15) | one
 [1,2) | [2018-01-02,2018-01-15) | [2018-01-15,2025-01-01) | bar
 [1,2) | [2018-01-15,2018-02-03) | [2015-01-01,2018-01-15) | foo
 [1,2) | [2018-01-15,2018-02-03) | [2018-01-15,2025-01-01) | bar
(4 rows)

DELETE FROM for_portion_of_test
  FOR PORTION OF valid1_at FROM '2018-01-20' TO NULL;
  SELECT * FROM for_portion_of_test ORDER BY id, valid1_at, valid2_at;
  id   |        valid1_at        |        valid2_at        | name 
-------+-------------------------+-------------------------+------
 [1,2) | [2018-01-02,2018-01-15) | [2015-01-01,2018-01-15) | one
 [1,2) | [2018-01-02,2018-01-15) | [2018-01-15,2025-01-01) | bar
 [1,2) | [2018-01-15,2018-01-20) | [2015-01-01,2018-01-15) | foo
 [1,2) | [2018-01-15,2018-01-20) | [2018-01-15,2025-01-01) | bar
(4 rows)

DELETE FROM for_portion_of_test
  FOR PORTION OF valid2_at FROM '2018-01-20' TO NULL;
  SELECT * FROM for_portion_of_test ORDER BY id, valid1_at, valid2_at;
  id   |        valid1_at        |        valid2_at        | name 
-------+-------------------------+-------------------------+------
 [1,2) | [2018-01-02,2018-01-15) | [2015-01-01,2018-01-15) | one
 [1,2) | [2018-01-02,2018-01-15) | [2018-01-15,2018-01-20) | bar
 [1,2) | [2018-01-15,2018-01-20) | [2015-01-01,2018-01-15) | foo
 [1,2) | [2018-01-15,2018-01-20) | [2018-01-15,2018-01-20) | bar
(4 rows)

-- Test with NULLs in the scalar/range key columns.
-- This won't happen if there is a PRIMARY KEY or UNIQUE constraint
-- but FOR PORTION OF shouldn't require that.
DROP TABLE for_portion_of_test;
CREATE UNLOGGED TABLE for_portion_of_test (
  id int4range,
  valid_at daterange,
  name text
);
INSERT INTO for_portion_of_test (id, valid_at, name) VALUES
  ('[1,2)', NULL, '1 null'),
  ('[1,2)', '(,)', '1 unbounded'),
  ('[1,2)', 'empty', '1 empty'),
  (NULL, NULL, NULL),
  (NULL, daterange('2018-01-01', '2019-01-01'), 'null key');
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO NULL
  SET name = 'NULL to NULL';
SELECT * FROM for_portion_of_test ORDER BY id, valid_at;
  id   |        valid_at         |     name     
-------+-------------------------+--------------
 [1,2) | empty                   | 1 empty
 [1,2) | (,)                     | NULL to NULL
 [1,2) |                         | 1 null
       | [2018-01-01,2019-01-01) | NULL to NULL
       |                         | 
(5 rows)

DROP TABLE for_portion_of_test;
--
-- UPDATE tests
--
CREATE TABLE for_portion_of_test (
  id int4range NOT NULL,
  valid_at daterange NOT NULL,
  name text NOT NULL,
  CONSTRAINT for_portion_of_pk PRIMARY KEY (id, valid_at WITHOUT OVERLAPS)
);
INSERT INTO for_portion_of_test (id, valid_at, name) VALUES
  ('[1,2)', '[2018-01-02,2018-02-03)', 'one'),
  ('[1,2)', '[2018-02-03,2018-03-03)', 'one'),
  ('[1,2)', '[2018-03-03,2018-04-04)', 'one'),
  ('[2,3)', '[2018-01-01,2018-01-05)', 'two'),
  ('[3,4)', '[2018-01-01,)', 'three'),
  ('[4,5)', '(,2018-04-01)', 'four'),
  ('[5,6)', '(,)', 'five')
  ;
\set QUIET false
-- Updating with a missing column fails
UPDATE for_portion_of_test
  FOR PORTION OF invalid_at FROM '2018-06-01' TO NULL
  SET name = 'foo'
  WHERE id = '[5,6)';
ERROR:  column or period "invalid_at" of relation "for_portion_of_test" does not exist
LINE 2:   FOR PORTION OF invalid_at FROM '2018-06-01' TO NULL
                         ^
-- Updating the range fails
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-06-01' TO NULL
  SET valid_at = '[1990-01-01,1999-01-01)'
  WHERE id = '[5,6)';
ERROR:  can't directly assign to "valid_at" in a FOR PORTION OF update
LINE 3:   SET valid_at = '[1990-01-01,1999-01-01)'
              ^
-- The wrong type fails
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM 1 TO 4
  SET name = 'nope'
  WHERE id = '[3,4)';
ERROR:  function pg_catalog.daterange(integer, integer) does not exist
LINE 2:   FOR PORTION OF valid_at FROM 1 TO 4
                         ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- Updating with timestamps reversed fails
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-06-01' TO '2018-01-01'
  SET name = 'three^1'
  WHERE id = '[3,4)';
ERROR:  range lower bound must be less than or equal to range upper bound
-- Updating with a subquery fails
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM (SELECT '2018-01-01') TO '2018-06-01'
  SET name = 'nope'
  WHERE id = '[3,4)';
ERROR:  cannot use subquery in FOR PORTION OF expression
LINE 2:   FOR PORTION OF valid_at FROM (SELECT '2018-01-01') TO '201...
                                       ^
-- Updating with a column fails
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM lower(valid_at) TO NULL
  SET name = 'nope'
  WHERE id = '[3,4)';
ERROR:  cannot use column reference in FOR PORTION OF expression
LINE 2:   FOR PORTION OF valid_at FROM lower(valid_at) TO NULL
                                             ^
-- Updating with timestamps equal does nothing
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-04-01' TO '2018-04-01'
  SET name = 'three^0'
  WHERE id = '[3,4)';
UPDATE 0
-- Updating a finite/open portion with a finite/open target
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-06-01' TO NULL
  SET name = 'three^1'
  WHERE id = '[3,4)';
UPDATE 2
-- Updating a finite/open portion with an open/finite target
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO '2018-03-01'
  SET name = 'three^2'
  WHERE id = '[3,4)';
UPDATE 2
-- Updating an open/finite portion with an open/finite target
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO '2018-02-01'
  SET name = 'four^1'
  WHERE id = '[4,5)';
UPDATE 2
-- Updating an open/finite portion with a finite/open target
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2017-01-01' TO NULL
  SET name = 'four^2'
  WHERE id = '[4,5)';
UPDATE 3
-- Updating a finite/finite portion with an exact fit
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2017-01-01' TO '2018-02-01'
  SET name = 'four^3'
  WHERE id = '[4,5)';
UPDATE 1
-- Updating an enclosed span
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO NULL
  SET name = 'two^2'
  WHERE id = '[2,3)';
UPDATE 1
-- Updating an open/open portion with a finite/finite target
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-01-01' TO '2019-01-01'
  SET name = 'five^1'
  WHERE id = '[5,6)';
UPDATE 3
-- Updating an enclosed span with separate protruding spans
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2017-01-01' TO '2020-01-01'
  SET name = 'five^2'
  WHERE id = '[5,6)';
UPDATE 5
-- Updating multiple enclosed spans
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO NULL
  SET name = 'one^2'
  WHERE id = '[1,2)';
UPDATE 3
-- Updating with a direct target
UPDATE for_portion_of_test
  FOR PORTION OF valid_at (daterange('2018-03-10', '2018-03-17'))
  SET name = 'one^3'
  WHERE id = '[1,2)';
UPDATE 3
-- Updating the non-range part of the PK:
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-02-15' TO NULL
  SET id = '[6,7)'
  WHERE id = '[1,2)';
UPDATE 5
-- UPDATE with no WHERE clause
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2030-01-01' TO NULL
  SET name = name || '*';
UPDATE 4
SELECT * FROM for_portion_of_test ORDER BY id, valid_at;
  id   |        valid_at         |   name   
-------+-------------------------+----------
 [1,2) | [2018-01-02,2018-02-03) | one^2
 [1,2) | [2018-02-03,2018-02-15) | one^2
 [2,3) | [2018-01-01,2018-01-05) | two^2
 [3,4) | [2018-01-01,2018-03-01) | three^2
 [3,4) | [2018-03-01,2018-06-01) | three
 [3,4) | [2018-06-01,2030-01-01) | three^1
 [3,4) | [2030-01-01,)           | three^1*
 [4,5) | (,2017-01-01)           | four^1
 [4,5) | [2017-01-01,2018-02-01) | four^3
 [4,5) | [2018-02-01,2018-04-01) | four^2
 [5,6) | (,2017-01-01)           | five
 [5,6) | [2017-01-01,2018-01-01) | five^2
 [5,6) | [2018-01-01,2019-01-01) | five^2
 [5,6) | [2019-01-01,2020-01-01) | five^2
 [5,6) | [2020-01-01,2030-01-01) | five
 [5,6) | [2030-01-01,)           | five*
 [6,7) | [2018-02-15,2018-03-03) | one^2
 [6,7) | [2018-03-03,2018-03-10) | one^2
 [6,7) | [2018-03-10,2018-03-17) | one^3
 [6,7) | [2018-03-17,2018-04-04) | one^2
(20 rows)

\set QUIET true
-- Updating with a shift/reduce conflict
-- (requires a tsrange column)
CREATE UNLOGGED TABLE for_portion_of_test2 (
  id int4range,
  valid_at tsrange,
  name text
);
INSERT INTO for_portion_of_test2 (id, valid_at, name) VALUES
  ('[1,2)', '[2000-01-01,2020-01-01)', 'one');
-- updates [2011-03-01 01:02:00, 2012-01-01) (note 2 minutes)
UPDATE for_portion_of_test2
  FOR PORTION OF valid_at
    FROM '2011-03-01'::timestamp + INTERVAL '1:02:03' HOUR TO MINUTE
    TO '2012-01-01'
  SET name = 'one^1'
  WHERE id = '[1,2)';
-- TO is used for the bound but not the INTERVAL:
-- syntax error
UPDATE for_portion_of_test2
  FOR PORTION OF valid_at
    FROM '2013-03-01'::timestamp + INTERVAL '1:02:03' HOUR
    TO '2014-01-01'
  SET name = 'one^2'
  WHERE id = '[1,2)';
ERROR:  syntax error at or near "'2014-01-01'"
LINE 4:     TO '2014-01-01'
               ^
-- adding parens fixes it
-- updates [2015-03-01 01:00:00, 2016-01-01) (no minutes)
UPDATE for_portion_of_test2
  FOR PORTION OF valid_at
    FROM ('2015-03-01'::timestamp + INTERVAL '1:02:03' HOUR)
    TO '2016-01-01'
  SET name = 'one^3'
  WHERE id = '[1,2)';
SELECT * FROM for_portion_of_test2 ORDER BY id, valid_at;
  id   |                   valid_at                    | name  
-------+-----------------------------------------------+-------
 [1,2) | ["2000-01-01 00:00:00","2011-03-01 01:02:00") | one
 [1,2) | ["2011-03-01 01:02:00","2012-01-01 00:00:00") | one^1
 [1,2) | ["2012-01-01 00:00:00","2015-03-01 01:00:00") | one
 [1,2) | ["2015-03-01 01:00:00","2016-01-01 00:00:00") | one^3
 [1,2) | ["2016-01-01 00:00:00","2020-01-01 00:00:00") | one
(5 rows)

DROP TABLE for_portion_of_test2;
-- UPDATE FOR PORTION OF in a CTE:
-- Visible to SELECT:
INSERT INTO for_portion_of_test (id, valid_at, name) VALUES
  ('[10,11)', '[2018-01-01,2020-01-01)', 'ten');
WITH update_apr AS (
  UPDATE for_portion_of_test
    FOR PORTION OF valid_at FROM '2018-04-01' TO '2018-05-01'
    SET name = 'Apr 2018'
    WHERE id = '[10,11)'
    RETURNING id, valid_at, name
)
SELECT *
  FROM for_portion_of_test AS t, update_apr
  WHERE t.id = update_apr.id;
   id    |        valid_at         | name |   id    |        valid_at         |   name   
---------+-------------------------+------+---------+-------------------------+----------
 [10,11) | [2018-01-01,2020-01-01) | ten  | [10,11) | [2018-04-01,2018-05-01) | Apr 2018
(1 row)

SELECT * FROM for_portion_of_test WHERE id = '[10,11)';
   id    |        valid_at         |   name   
---------+-------------------------+----------
 [10,11) | [2018-04-01,2018-05-01) | Apr 2018
 [10,11) | [2018-01-01,2018-04-01) | ten
 [10,11) | [2018-05-01,2020-01-01) | ten
(3 rows)

-- Not visible to UPDATE:
-- Tuples updated/inserted within the CTE are not visible to the main query yet,
-- but neither are old tuples the CTE changed:
INSERT INTO for_portion_of_test (id, valid_at, name) VALUES
  ('[11,12)', '[2018-01-01,2020-01-01)', 'eleven');
WITH update_apr AS (
  UPDATE for_portion_of_test
    FOR PORTION OF valid_at FROM '2018-04-01' TO '2018-05-01'
    SET name = 'Apr 2018'
    WHERE id = '[11,12)'
    RETURNING id, valid_at, name
)
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-05-01' TO '2018-06-01'
  AS t
  SET name = 'May 2018'
  FROM update_apr AS j
  WHERE t.id = j.id;
SELECT * FROM for_portion_of_test WHERE id = '[11,12)';
   id    |        valid_at         |   name   
---------+-------------------------+----------
 [11,12) | [2018-04-01,2018-05-01) | Apr 2018
 [11,12) | [2018-01-01,2018-04-01) | eleven
 [11,12) | [2018-05-01,2020-01-01) | eleven
(3 rows)

DELETE FROM for_portion_of_test WHERE id IN ('[10,11)', '[11,12)');
-- UPDATE FOR PORTION OF in a PL/pgSQL function
INSERT INTO for_portion_of_test (id, valid_at, name) VALUES
  ('[10,11)', '[2018-01-01,2020-01-01)', 'ten');
CREATE FUNCTION fpo_update(_id int4range, _target_from date, _target_til date)
RETURNS void LANGUAGE plpgsql AS
$$
BEGIN
  UPDATE for_portion_of_test
    FOR PORTION OF valid_at FROM $2 TO $3
    SET name = concat(_target_from::text, ' to ', _target_til::text)
    WHERE id = $1;
END;
$$;
SELECT fpo_update('[10,11)', '2015-01-01', '2019-01-01');
 fpo_update 
------------
 
(1 row)

SELECT * FROM for_portion_of_test WHERE id = '[10,11)';
   id    |        valid_at         |           name           
---------+-------------------------+--------------------------
 [10,11) | [2018-01-01,2019-01-01) | 2015-01-01 to 2019-01-01
 [10,11) | [2019-01-01,2020-01-01) | ten
(2 rows)

DROP TABLE for_portion_of_test;
--
-- DELETE tests
--
CREATE TABLE for_portion_of_test (
  id int4range NOT NULL,
  valid_at daterange NOT NULL,
  name text NOT NULL,
  CONSTRAINT for_portion_of_pk PRIMARY KEY (id, valid_at WITHOUT OVERLAPS)
);
INSERT INTO for_portion_of_test (id, valid_at, name) VALUES
  ('[1,2)', '[2018-01-02,2018-02-03)', 'one'),
  ('[1,2)', '[2018-02-03,2018-03-03)', 'one'),
  ('[1,2)', '[2018-03-03,2018-04-04)', 'one'),
  ('[2,3)', '[2018-01-01,2018-01-05)', 'two'),
  ('[3,4)', '[2018-01-01,)', 'three'),
  ('[4,5)', '(,2018-04-01)', 'four'),
  ('[5,6)', '(,)', 'five'),
  ('[6,7)', '[2018-01-01,)', 'six'),
  ('[7,8)', '(,2018-04-01)', 'seven'),
  ('[8,9)', '[2018-01-02,2018-02-03)', 'eight'),
  ('[8,9)', '[2018-02-03,2018-03-03)', 'eight'),
  ('[8,9)', '[2018-03-03,2018-04-04)', 'eight')
  ;
\set QUIET false
-- Deleting with a missing column fails
DELETE FROM for_portion_of_test
  FOR PORTION OF invalid_at FROM '2018-06-01' TO NULL
  WHERE id = '[5,6)';
ERROR:  column or period "invalid_at" of relation "for_portion_of_test" does not exist
LINE 2:   FOR PORTION OF invalid_at FROM '2018-06-01' TO NULL
                         ^
-- The wrong type fails
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM 1 TO 4
  WHERE id = '[3,4)';
ERROR:  function pg_catalog.daterange(integer, integer) does not exist
LINE 2:   FOR PORTION OF valid_at FROM 1 TO 4
                         ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- Deleting with timestamps reversed fails
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-06-01' TO '2018-01-01'
  WHERE id = '[3,4)';
ERROR:  range lower bound must be less than or equal to range upper bound
-- Deleting with a subquery fails
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM (SELECT '2018-01-01') TO '2018-06-01'
  WHERE id = '[3,4)';
ERROR:  cannot use subquery in FOR PORTION OF expression
LINE 2:   FOR PORTION OF valid_at FROM (SELECT '2018-01-01') TO '201...
                                       ^
-- Deleting with a column fails
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM lower(valid_at) TO NULL
  WHERE id = '[3,4)';
ERROR:  cannot use column reference in FOR PORTION OF expression
LINE 2:   FOR PORTION OF valid_at FROM lower(valid_at) TO NULL
                                             ^
-- Deleting with timestamps equal does nothing
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-04-01' TO '2018-04-01'
  WHERE id = '[3,4)';
DELETE 0
-- Deleting a finite/open portion with a finite/open target
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-06-01' TO NULL
  WHERE id = '[3,4)';
DELETE 2
-- Deleting a finite/open portion with an open/finite target
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO '2018-03-01'
  WHERE id = '[6,7)';
DELETE 2
-- Deleting an open/finite portion with an open/finite target
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO '2018-02-01'
  WHERE id = '[4,5)';
DELETE 2
-- Deleting an open/finite portion with a finite/open target
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2017-01-01' TO NULL
  WHERE id = '[7,8)';
DELETE 2
-- Deleting a finite/finite portion with an exact fit
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-02-01' TO '2018-04-01'
  WHERE id = '[4,5)';
DELETE 1
-- Deleting an enclosed span
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO NULL
  WHERE id = '[2,3)';
DELETE 1
-- Deleting an open/open portion with a finite/finite target
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-01-01' TO '2019-01-01'
  WHERE id = '[5,6)';
DELETE 3
-- Deleting an enclosed span with separate protruding spans
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-02-03' TO '2018-03-03'
  WHERE id = '[1,2)';
DELETE 1
-- Deleting multiple enclosed spans
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO NULL
  WHERE id = '[8,9)';
DELETE 3
-- Deleting with a direct target
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at (daterange('2018-03-10', '2018-03-17'))
  WHERE id = '[1,2)';
DELETE 3
-- DELETE with no WHERE clause
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2030-01-01' TO NULL;
DELETE 4
SELECT * FROM for_portion_of_test ORDER BY id, valid_at;
  id   |        valid_at         | name  
-------+-------------------------+-------
 [1,2) | [2018-01-02,2018-02-03) | one
 [1,2) | [2018-03-03,2018-03-10) | one
 [1,2) | [2018-03-17,2018-04-04) | one
 [3,4) | [2018-01-01,2018-06-01) | three
 [5,6) | (,2018-01-01)           | five
 [5,6) | [2019-01-01,2030-01-01) | five
 [6,7) | [2018-03-01,2030-01-01) | six
 [7,8) | (,2017-01-01)           | seven
(8 rows)

\set QUIET true
-- UPDATE ... RETURNING returns only the updated values (not the inserted side values)
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-02-01' TO '2018-02-15'
  SET name = 'three^3'
  WHERE id = '[3,4)'
  RETURNING *;
  id   |        valid_at         |  name   
-------+-------------------------+---------
 [3,4) | [2018-02-01,2018-02-15) | three^3
(1 row)

-- DELETE ... RETURNING returns the deleted values (regardless of bounds)
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-02-02' TO '2018-02-03'
  WHERE id = '[3,4)'
  RETURNING *;
  id   |        valid_at         |  name   
-------+-------------------------+---------
 [3,4) | [2018-02-01,2018-02-15) | three^3
(1 row)

-- DELETE FOR PORTION OF in a PL/pgSQL function
INSERT INTO for_portion_of_test (id, valid_at, name) VALUES
  ('[10,11)', '[2018-01-01,2020-01-01)', 'ten');
CREATE FUNCTION fpo_delete(_id int4range, _target_from date, _target_til date)
RETURNS void LANGUAGE plpgsql AS
$$
BEGIN
  DELETE FROM for_portion_of_test
    FOR PORTION OF valid_at FROM $2 TO $3
    WHERE id = $1;
END;
$$;
SELECT fpo_delete('[10,11)', '2015-01-01', '2019-01-01');
 fpo_delete 
------------
 
(1 row)

SELECT * FROM for_portion_of_test WHERE id = '[10,11)';
   id    |        valid_at         | name 
---------+-------------------------+------
 [10,11) | [2019-01-01,2020-01-01) | ten
(1 row)

DELETE FROM for_portion_of_test WHERE id IN ('[10,11)');
-- test that we run triggers on the UPDATE/DELETEd row and the INSERTed rows
CREATE FUNCTION dump_trigger()
RETURNS TRIGGER LANGUAGE plpgsql AS
$$
BEGIN
  IF TG_PERIOD_NAME IS NOT NULL THEN
    RAISE NOTICE '%: % % FOR PORTION OF % (%) %:',
      TG_NAME, TG_WHEN, TG_OP, TG_PERIOD_NAME, TG_PERIOD_BOUNDS, TG_LEVEL;
  ELSE
    RAISE NOTICE '%: % % %:',
      TG_NAME, TG_WHEN, TG_OP, TG_LEVEL;
  END IF;

  IF TG_ARGV[0] THEN
    RAISE NOTICE '  old: %', (SELECT string_agg(old_table::text, '\n       ') FROM old_table);
  ELSE
    RAISE NOTICE '  old: %', OLD.valid_at;
  END IF;
  IF TG_ARGV[1] THEN
    RAISE NOTICE '  new: %', (SELECT string_agg(new_table::text, '\n       ') FROM new_table);
  ELSE
    RAISE NOTICE '  new: %', NEW.valid_at;
  END IF;

  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
END;
$$;
-- statement triggers:
CREATE TRIGGER fpo_before_stmt
BEFORE INSERT OR UPDATE OR DELETE ON for_portion_of_test
FOR EACH STATEMENT EXECUTE PROCEDURE dump_trigger(false, false);
CREATE TRIGGER fpo_after_insert_stmt
AFTER INSERT ON for_portion_of_test
FOR EACH STATEMENT EXECUTE PROCEDURE dump_trigger(false, false);
CREATE TRIGGER fpo_after_update_stmt
AFTER UPDATE ON for_portion_of_test
FOR EACH STATEMENT EXECUTE PROCEDURE dump_trigger(false, false);
CREATE TRIGGER fpo_after_delete_stmt
AFTER DELETE ON for_portion_of_test
FOR EACH STATEMENT EXECUTE PROCEDURE dump_trigger(false, false);
-- row triggers:
CREATE TRIGGER fpo_before_row
BEFORE INSERT OR UPDATE OR DELETE ON for_portion_of_test
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(false, false);
CREATE TRIGGER fpo_after_insert_row
AFTER INSERT ON for_portion_of_test
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(false, false);
CREATE TRIGGER fpo_after_update_row
AFTER UPDATE ON for_portion_of_test
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(false, false);
CREATE TRIGGER fpo_after_delete_row
AFTER DELETE ON for_portion_of_test
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(false, false);
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2021-01-01' TO '2022-01-01'
  SET name = 'five^3'
  WHERE id = '[5,6)';
NOTICE:  fpo_before_stmt: BEFORE UPDATE FOR PORTION OF valid_at ([2021-01-01,2022-01-01)) STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE UPDATE FOR PORTION OF valid_at ([2021-01-01,2022-01-01)) ROW:
NOTICE:    old: [2019-01-01,2030-01-01)
NOTICE:    new: [2021-01-01,2022-01-01)
NOTICE:  fpo_before_stmt: BEFORE INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2019-01-01,2021-01-01)
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2019-01-01,2021-01-01)
NOTICE:  fpo_after_insert_stmt: AFTER INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_stmt: BEFORE INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2022-01-01,2030-01-01)
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2022-01-01,2030-01-01)
NOTICE:  fpo_after_insert_stmt: AFTER INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_after_update_row: AFTER UPDATE FOR PORTION OF valid_at ([2021-01-01,2022-01-01)) ROW:
NOTICE:    old: [2019-01-01,2030-01-01)
NOTICE:    new: [2021-01-01,2022-01-01)
NOTICE:  fpo_after_update_stmt: AFTER UPDATE FOR PORTION OF valid_at ([2021-01-01,2022-01-01)) STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2023-01-01' TO '2024-01-01'
  WHERE id = '[5,6)';
NOTICE:  fpo_before_stmt: BEFORE DELETE FOR PORTION OF valid_at ([2023-01-01,2024-01-01)) STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE DELETE FOR PORTION OF valid_at ([2023-01-01,2024-01-01)) ROW:
NOTICE:    old: [2022-01-01,2030-01-01)
NOTICE:    new: <NULL>
NOTICE:  fpo_before_stmt: BEFORE INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2022-01-01,2023-01-01)
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2022-01-01,2023-01-01)
NOTICE:  fpo_after_insert_stmt: AFTER INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_stmt: BEFORE INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2024-01-01,2030-01-01)
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2024-01-01,2030-01-01)
NOTICE:  fpo_after_insert_stmt: AFTER INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_after_delete_row: AFTER DELETE FOR PORTION OF valid_at ([2023-01-01,2024-01-01)) ROW:
NOTICE:    old: [2022-01-01,2030-01-01)
NOTICE:    new: <NULL>
NOTICE:  fpo_after_delete_stmt: AFTER DELETE FOR PORTION OF valid_at ([2023-01-01,2024-01-01)) STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
SELECT * FROM for_portion_of_test ORDER BY id, valid_at;
  id   |        valid_at         |  name   
-------+-------------------------+---------
 [1,2) | [2018-01-02,2018-02-03) | one
 [1,2) | [2018-03-03,2018-03-10) | one
 [1,2) | [2018-03-17,2018-04-04) | one
 [3,4) | [2018-01-01,2018-02-01) | three
 [3,4) | [2018-02-01,2018-02-02) | three^3
 [3,4) | [2018-02-03,2018-02-15) | three^3
 [3,4) | [2018-02-15,2018-06-01) | three
 [5,6) | (,2018-01-01)           | five
 [5,6) | [2019-01-01,2021-01-01) | five
 [5,6) | [2021-01-01,2022-01-01) | five^3
 [5,6) | [2022-01-01,2023-01-01) | five
 [5,6) | [2024-01-01,2030-01-01) | five
 [6,7) | [2018-03-01,2030-01-01) | six
 [7,8) | (,2017-01-01)           | seven
(14 rows)

-- Triggers with a custom transition table name:
DROP TABLE for_portion_of_test;
CREATE TABLE for_portion_of_test (
  id int4range,
  valid_at daterange,
  name text
);
INSERT INTO for_portion_of_test VALUES ('[1,2)', '[2018-01-01,2020-01-01)', 'one');
-- statement triggers:
CREATE TRIGGER fpo_before_stmt
BEFORE INSERT OR UPDATE OR DELETE ON for_portion_of_test
FOR EACH STATEMENT EXECUTE PROCEDURE dump_trigger(false, false);
CREATE TRIGGER fpo_after_insert_stmt
AFTER INSERT ON for_portion_of_test
REFERENCING NEW TABLE AS new_table
FOR EACH STATEMENT EXECUTE PROCEDURE dump_trigger(false, true);
CREATE TRIGGER fpo_after_update_stmt
AFTER UPDATE ON for_portion_of_test
REFERENCING NEW TABLE AS new_table OLD TABLE AS old_table
FOR EACH STATEMENT EXECUTE PROCEDURE dump_trigger(true, true);
CREATE TRIGGER fpo_after_delete_stmt
AFTER DELETE ON for_portion_of_test
REFERENCING OLD TABLE AS old_table
FOR EACH STATEMENT EXECUTE PROCEDURE dump_trigger(true, false);
-- row triggers:
CREATE TRIGGER fpo_before_row
BEFORE INSERT OR UPDATE OR DELETE ON for_portion_of_test
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(false, false);
CREATE TRIGGER fpo_after_insert_row
AFTER INSERT ON for_portion_of_test
REFERENCING NEW TABLE AS new_table
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(false, true);
CREATE TRIGGER fpo_after_update_row
AFTER UPDATE ON for_portion_of_test
REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(true, true);
CREATE TRIGGER fpo_after_delete_row
AFTER DELETE ON for_portion_of_test
REFERENCING OLD TABLE AS old_table
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(true, false);
BEGIN;
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-01-15' TO '2019-01-01'
  SET name = '2018-01-15_to_2019-01-01';
NOTICE:  fpo_before_stmt: BEFORE UPDATE FOR PORTION OF valid_at ([2018-01-15,2019-01-01)) STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE UPDATE FOR PORTION OF valid_at ([2018-01-15,2019-01-01)) ROW:
NOTICE:    old: [2018-01-01,2020-01-01)
NOTICE:    new: [2018-01-15,2019-01-01)
NOTICE:  fpo_before_stmt: BEFORE INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2018-01-01,2018-01-15)
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: ("[1,2)","[2018-01-01,2018-01-15)",one)
NOTICE:  fpo_after_insert_stmt: AFTER INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: ("[1,2)","[2018-01-01,2018-01-15)",one)
NOTICE:  fpo_before_stmt: BEFORE INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2019-01-01,2020-01-01)
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: ("[1,2)","[2019-01-01,2020-01-01)",one)
NOTICE:  fpo_after_insert_stmt: AFTER INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: ("[1,2)","[2019-01-01,2020-01-01)",one)
NOTICE:  fpo_after_update_row: AFTER UPDATE FOR PORTION OF valid_at ([2018-01-15,2019-01-01)) ROW:
NOTICE:    old: ("[1,2)","[2018-01-01,2020-01-01)",one)
NOTICE:    new: ("[1,2)","[2018-01-15,2019-01-01)",2018-01-15_to_2019-01-01)
NOTICE:  fpo_after_update_stmt: AFTER UPDATE FOR PORTION OF valid_at ([2018-01-15,2019-01-01)) STATEMENT:
NOTICE:    old: ("[1,2)","[2018-01-01,2020-01-01)",one)
NOTICE:    new: ("[1,2)","[2018-01-15,2019-01-01)",2018-01-15_to_2019-01-01)
ROLLBACK;
BEGIN;
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO '2018-01-21';
NOTICE:  fpo_before_stmt: BEFORE DELETE FOR PORTION OF valid_at ((,2018-01-21)) STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE DELETE FOR PORTION OF valid_at ((,2018-01-21)) ROW:
NOTICE:    old: [2018-01-01,2020-01-01)
NOTICE:    new: <NULL>
NOTICE:  fpo_before_stmt: BEFORE INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2018-01-21,2020-01-01)
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: ("[1,2)","[2018-01-21,2020-01-01)",one)
NOTICE:  fpo_after_insert_stmt: AFTER INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: ("[1,2)","[2018-01-21,2020-01-01)",one)
NOTICE:  fpo_after_delete_row: AFTER DELETE FOR PORTION OF valid_at ((,2018-01-21)) ROW:
NOTICE:    old: ("[1,2)","[2018-01-01,2020-01-01)",one)
NOTICE:    new: <NULL>
NOTICE:  fpo_after_delete_stmt: AFTER DELETE FOR PORTION OF valid_at ((,2018-01-21)) STATEMENT:
NOTICE:    old: ("[1,2)","[2018-01-01,2020-01-01)",one)
NOTICE:    new: <NULL>
ROLLBACK;
BEGIN;
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO '2018-01-02'
  SET name = 'NULL_to_2018-01-01';
NOTICE:  fpo_before_stmt: BEFORE UPDATE FOR PORTION OF valid_at ((,2018-01-02)) STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE UPDATE FOR PORTION OF valid_at ((,2018-01-02)) ROW:
NOTICE:    old: [2018-01-01,2020-01-01)
NOTICE:    new: [2018-01-01,2018-01-02)
NOTICE:  fpo_before_stmt: BEFORE INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: <NULL>
NOTICE:  fpo_before_row: BEFORE INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2018-01-02,2020-01-01)
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: ("[1,2)","[2018-01-02,2020-01-01)",one)
NOTICE:  fpo_after_insert_stmt: AFTER INSERT STATEMENT:
NOTICE:    old: <NULL>
NOTICE:    new: ("[1,2)","[2018-01-02,2020-01-01)",one)
NOTICE:  fpo_after_update_row: AFTER UPDATE FOR PORTION OF valid_at ((,2018-01-02)) ROW:
NOTICE:    old: ("[1,2)","[2018-01-01,2020-01-01)",one)
NOTICE:    new: ("[1,2)","[2018-01-01,2018-01-02)",NULL_to_2018-01-01)
NOTICE:  fpo_after_update_stmt: AFTER UPDATE FOR PORTION OF valid_at ((,2018-01-02)) STATEMENT:
NOTICE:    old: ("[1,2)","[2018-01-01,2020-01-01)",one)
NOTICE:    new: ("[1,2)","[2018-01-01,2018-01-02)",NULL_to_2018-01-01)
ROLLBACK;
-- Deferred triggers
-- (must be CONSTRAINT triggers thus AFTER ROW with no transition tables)
DROP TABLE for_portion_of_test;
CREATE TABLE for_portion_of_test (
  id int4range,
  valid_at daterange,
  name text
);
INSERT INTO for_portion_of_test (id, valid_at, name) VALUES
  ('[1,2)', '[2018-01-01,2020-01-01)', 'one');
CREATE CONSTRAINT TRIGGER fpo_after_insert_row
AFTER INSERT ON for_portion_of_test
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(false, false);
CREATE CONSTRAINT TRIGGER fpo_after_update_row
AFTER UPDATE ON for_portion_of_test
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(false, false);
CREATE CONSTRAINT TRIGGER fpo_after_delete_row
AFTER DELETE ON for_portion_of_test
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW EXECUTE PROCEDURE dump_trigger(false, false);
BEGIN;
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-01-15' TO '2019-01-01'
  SET name = '2018-01-15_to_2019-01-01';
COMMIT;
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2018-01-01,2018-01-15)
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2019-01-01,2020-01-01)
NOTICE:  fpo_after_update_row: AFTER UPDATE FOR PORTION OF valid_at ([2018-01-15,2019-01-01)) ROW:
NOTICE:    old: [2018-01-01,2020-01-01)
NOTICE:    new: [2018-01-15,2019-01-01)
BEGIN;
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO '2018-01-21';
COMMIT;
NOTICE:  fpo_after_insert_row: AFTER INSERT ROW:
NOTICE:    old: <NULL>
NOTICE:    new: [2018-01-21,2019-01-01)
NOTICE:  fpo_after_delete_row: AFTER DELETE FOR PORTION OF valid_at ((,2018-01-21)) ROW:
NOTICE:    old: [2018-01-15,2019-01-01)
NOTICE:    new: <NULL>
NOTICE:  fpo_after_delete_row: AFTER DELETE FOR PORTION OF valid_at ((,2018-01-21)) ROW:
NOTICE:    old: [2018-01-01,2018-01-15)
NOTICE:    new: <NULL>
BEGIN;
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM NULL TO '2018-01-02'
  SET name = 'NULL_to_2018-01-01';
COMMIT;
SELECT * FROM for_portion_of_test;
  id   |        valid_at         |           name           
-------+-------------------------+--------------------------
 [1,2) | [2019-01-01,2020-01-01) | one
 [1,2) | [2018-01-21,2019-01-01) | 2018-01-15_to_2019-01-01
(2 rows)

-- test FOR PORTION OF from triggers during FOR PORTION OF:
DROP TABLE for_portion_of_test;
CREATE TABLE for_portion_of_test (
  id int4range,
  valid_at daterange,
  name text
);
INSERT INTO for_portion_of_test (id, valid_at, name) VALUES
  ('[1,2)', '[2018-01-01,2020-01-01)', 'one'),
  ('[2,3)', '[2018-01-01,2020-01-01)', 'two'),
  ('[3,4)', '[2018-01-01,2020-01-01)', 'three'),
  ('[4,5)', '[2018-01-01,2020-01-01)', 'four');
CREATE FUNCTION trg_fpo_update()
RETURNS TRIGGER LANGUAGE plpgsql AS
$$
BEGIN
  IF pg_trigger_depth() = 1 THEN
    UPDATE for_portion_of_test
      FOR PORTION OF valid_at FROM '2018-02-01' TO '2018-03-01'
      SET name = CONCAT(name, '^')
      WHERE id = OLD.id;
  END IF;
  RETURN CASE WHEN 'TG_OP' = 'DELETE' THEN OLD ELSE NEW END;
END;
$$;
CREATE FUNCTION trg_fpo_delete()
RETURNS TRIGGER LANGUAGE plpgsql AS
$$
BEGIN
  IF pg_trigger_depth() = 1 THEN
    DELETE FROM for_portion_of_test
      FOR PORTION OF valid_at FROM '2018-03-01' TO '2018-04-01'
      WHERE id = OLD.id;
  END IF;
  RETURN CASE WHEN 'TG_OP' = 'DELETE' THEN OLD ELSE NEW END;
END;
$$;
-- UPDATE FOR PORTION OF from a trigger fired by UPDATE FOR PORTION OF
CREATE TRIGGER fpo_after_update_row
AFTER UPDATE ON for_portion_of_test
FOR EACH ROW EXECUTE PROCEDURE trg_fpo_update();
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-05-01' TO '2018-06-01'
  SET name = CONCAT(name, '*')
  WHERE id = '[1,2)';
SELECT * FROM for_portion_of_test WHERE id = '[1,2)' ORDER BY id, valid_at;
  id   |        valid_at         | name 
-------+-------------------------+------
 [1,2) | [2018-01-01,2018-02-01) | one
 [1,2) | [2018-02-01,2018-03-01) | one^
 [1,2) | [2018-03-01,2018-05-01) | one
 [1,2) | [2018-05-01,2018-06-01) | one*
 [1,2) | [2018-06-01,2020-01-01) | one
(5 rows)

DROP TRIGGER fpo_after_update_row ON for_portion_of_test;
-- UPDATE FOR PORTION OF from a trigger fired by DELETE FOR PORTION OF
CREATE TRIGGER fpo_after_delete_row
AFTER DELETE ON for_portion_of_test
FOR EACH ROW EXECUTE PROCEDURE trg_fpo_update();
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-05-01' TO '2018-06-01'
  WHERE id = '[2,3)';
SELECT * FROM for_portion_of_test WHERE id = '[2,3)' ORDER BY id, valid_at;
  id   |        valid_at         | name 
-------+-------------------------+------
 [2,3) | [2018-01-01,2018-02-01) | two
 [2,3) | [2018-02-01,2018-03-01) | two^
 [2,3) | [2018-03-01,2018-05-01) | two
 [2,3) | [2018-06-01,2020-01-01) | two
(4 rows)

DROP TRIGGER fpo_after_delete_row ON for_portion_of_test;
-- DELETE FOR PORTION OF from a trigger fired by UPDATE FOR PORTION OF
CREATE TRIGGER fpo_after_update_row
AFTER UPDATE ON for_portion_of_test
FOR EACH ROW EXECUTE PROCEDURE trg_fpo_delete();
UPDATE for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-05-01' TO '2018-06-01'
  SET name = CONCAT(name, '*')
  WHERE id = '[3,4)';
SELECT * FROM for_portion_of_test WHERE id = '[3,4)' ORDER BY id, valid_at;
  id   |        valid_at         |  name  
-------+-------------------------+--------
 [3,4) | [2018-01-01,2018-03-01) | three
 [3,4) | [2018-04-01,2018-05-01) | three
 [3,4) | [2018-05-01,2018-06-01) | three*
 [3,4) | [2018-06-01,2020-01-01) | three
(4 rows)

DROP TRIGGER fpo_after_update_row ON for_portion_of_test;
-- DELETE FOR PORTION OF from a trigger fired by DELETE FOR PORTION OF
CREATE TRIGGER fpo_after_delete_row
AFTER DELETE ON for_portion_of_test
FOR EACH ROW EXECUTE PROCEDURE trg_fpo_delete();
DELETE FROM for_portion_of_test
  FOR PORTION OF valid_at FROM '2018-05-01' TO '2018-06-01'
  WHERE id = '[4,5)';
SELECT * FROM for_portion_of_test WHERE id = '[4,5)' ORDER BY id, valid_at;
  id   |        valid_at         | name 
-------+-------------------------+------
 [4,5) | [2018-01-01,2018-03-01) | four
 [4,5) | [2018-04-01,2018-05-01) | four
 [4,5) | [2018-06-01,2020-01-01) | four
(3 rows)

DROP TRIGGER fpo_after_delete_row ON for_portion_of_test;
-- Test with multiranges
CREATE TABLE for_portion_of_test2 (
  id int4range NOT NULL,
  valid_at datemultirange NOT NULL,
  name text NOT NULL,
  CONSTRAINT for_portion_of_test2_pk PRIMARY KEY (id, valid_at WITHOUT OVERLAPS)
);
INSERT INTO for_portion_of_test2 (id, valid_at, name) VALUES
  ('[1,2)', datemultirange(daterange('2018-01-02', '2018-02-03)'), daterange('2018-02-04', '2018-03-03')), 'one'),
  ('[1,2)', datemultirange(daterange('2018-03-03', '2018-04-04)')), 'one'),
  ('[2,3)', datemultirange(daterange('2018-01-01', '2018-05-01)')), 'two'),
  ('[3,4)', datemultirange(daterange('2018-01-01', null)), 'three');
  ;
UPDATE for_portion_of_test2
  FOR PORTION OF valid_at (datemultirange(daterange('2018-01-10', '2018-02-10'), daterange('2018-03-05', '2018-05-01')))
  SET name = 'one^1'
  WHERE id = '[1,2)';
DELETE FROM for_portion_of_test2
  FOR PORTION OF valid_at (datemultirange(daterange('2018-01-15', '2018-02-15'), daterange('2018-03-01', '2018-03-15')))
  WHERE id = '[2,3)';
SELECT * FROM for_portion_of_test2 ORDER BY id, valid_at;
  id   |                                 valid_at                                  | name  
-------+---------------------------------------------------------------------------+-------
 [1,2) | {[2018-01-02,2018-01-10),[2018-02-10,2018-03-03)}                         | one
 [1,2) | {[2018-01-10,2018-02-03),[2018-02-04,2018-02-10)}                         | one^1
 [1,2) | {[2018-03-03,2018-03-05)}                                                 | one
 [1,2) | {[2018-03-05,2018-04-04)}                                                 | one^1
 [2,3) | {[2018-01-01,2018-01-15),[2018-02-15,2018-03-01),[2018-03-15,2018-05-01)} | two
 [3,4) | {[2018-01-01,)}                                                           | three
(6 rows)

DROP TABLE for_portion_of_test2;
-- Test with a custom range type
CREATE TYPE mydaterange AS range(subtype=date);
CREATE TABLE for_portion_of_test2 (
  id int4range NOT NULL,
  valid_at mydaterange NOT NULL,
  name text NOT NULL,
  CONSTRAINT for_portion_of_test2_pk PRIMARY KEY (id, valid_at WITHOUT OVERLAPS)
);
INSERT INTO for_portion_of_test2 (id, valid_at, name) VALUES
  ('[1,2)', '[2018-01-02,2018-02-03)', 'one'),
  ('[1,2)', '[2018-02-03,2018-03-03)', 'one'),
  ('[1,2)', '[2018-03-03,2018-04-04)', 'one'),
  ('[2,3)', '[2018-01-01,2018-05-01)', 'two'),
  ('[3,4)', '[2018-01-01,)', 'three');
  ;
UPDATE for_portion_of_test2
  FOR PORTION OF valid_at FROM '2018-01-10' TO '2018-02-10'
  SET name = 'one^1'
  WHERE id = '[1,2)';
DELETE FROM for_portion_of_test2
  FOR PORTION OF valid_at FROM '2018-01-15' TO '2018-02-15'
  WHERE id = '[2,3)';
SELECT * FROM for_portion_of_test2 ORDER BY id, valid_at;
  id   |        valid_at         | name  
-------+-------------------------+-------
 [1,2) | [2018-01-02,2018-01-10) | one
 [1,2) | [2018-01-10,2018-02-03) | one^1
 [1,2) | [2018-02-03,2018-02-10) | one^1
 [1,2) | [2018-02-10,2018-03-03) | one
 [1,2) | [2018-03-03,2018-04-04) | one
 [2,3) | [2018-01-01,2018-01-15) | two
 [2,3) | [2018-02-15,2018-05-01) | two
 [3,4) | [2018-01-01,)           | three
(8 rows)

DROP TABLE for_portion_of_test2;
DROP TYPE mydaterange;
-- Test FOR PORTION OF against a partitioned table.
-- temporal_partitioned_1 has the same attnums as the root
-- temporal_partitioned_3 has the different attnums from the root
-- temporal_partitioned_5 has the different attnums too, but reversed
CREATE TABLE temporal_partitioned (
  id int4range,
  valid_at daterange,
  name text,
  CONSTRAINT temporal_paritioned_uq UNIQUE (id, valid_at WITHOUT OVERLAPS)
) PARTITION BY LIST (id);
CREATE TABLE temporal_partitioned_1 PARTITION OF temporal_partitioned FOR VALUES IN ('[1,2)', '[2,3)');
CREATE TABLE temporal_partitioned_3 PARTITION OF temporal_partitioned FOR VALUES IN ('[3,4)', '[4,5)');
CREATE TABLE temporal_partitioned_5 PARTITION OF temporal_partitioned FOR VALUES IN ('[5,6)', '[6,7)');
ALTER TABLE temporal_partitioned DETACH PARTITION temporal_partitioned_3;
ALTER TABLE temporal_partitioned_3 DROP COLUMN id, DROP COLUMN valid_at;
ALTER TABLE temporal_partitioned_3 ADD COLUMN id int4range NOT NULL, ADD COLUMN valid_at daterange NOT NULL;
ALTER TABLE temporal_partitioned ATTACH PARTITION temporal_partitioned_3 FOR VALUES IN ('[3,4)', '[4,5)');
ALTER TABLE temporal_partitioned DETACH PARTITION temporal_partitioned_5;
ALTER TABLE temporal_partitioned_5 DROP COLUMN id, DROP COLUMN valid_at;
ALTER TABLE temporal_partitioned_5 ADD COLUMN valid_at daterange NOT NULL, ADD COLUMN id int4range NOT NULL;
ALTER TABLE temporal_partitioned ATTACH PARTITION temporal_partitioned_5 FOR VALUES IN ('[5,6)', '[6,7)');
INSERT INTO temporal_partitioned (id, valid_at, name) VALUES
  ('[1,2)', daterange('2000-01-01', '2010-01-01'), 'one'),
  ('[3,4)', daterange('2000-01-01', '2010-01-01'), 'three'),
  ('[5,6)', daterange('2000-01-01', '2010-01-01'), 'five');
SELECT * FROM temporal_partitioned;
  id   |        valid_at         | name  
-------+-------------------------+-------
 [1,2) | [2000-01-01,2010-01-01) | one
 [3,4) | [2000-01-01,2010-01-01) | three
 [5,6) | [2000-01-01,2010-01-01) | five
(3 rows)

-- Update without moving within partition 1
UPDATE temporal_partitioned FOR PORTION OF valid_at FROM '2000-03-01' TO '2000-04-01'
  SET name = 'one^1'
  WHERE id = '[1,2)';
-- Update without moving within partition 3
UPDATE temporal_partitioned FOR PORTION OF valid_at FROM '2000-03-01' TO '2000-04-01'
  SET name = 'three^1'
  WHERE id = '[3,4)';
-- Update without moving within partition 5
UPDATE temporal_partitioned FOR PORTION OF valid_at FROM '2000-03-01' TO '2000-04-01'
  SET name = 'five^1'
  WHERE id = '[5,6)';
-- Move from partition 1 to partition 3
UPDATE temporal_partitioned FOR PORTION OF valid_at FROM '2000-06-01' TO '2000-07-01'
  SET name = 'one^2',
      id = '[4,5)'
  WHERE id = '[1,2)';
-- Move from partition 3 to partition 1
UPDATE temporal_partitioned FOR PORTION OF valid_at FROM '2000-06-01' TO '2000-07-01'
  SET name = 'three^2',
      id = '[2,3)'
  WHERE id = '[3,4)';
-- Move from partition 5 to partition 3
UPDATE temporal_partitioned FOR PORTION OF valid_at FROM '2000-06-01' TO '2000-07-01'
  SET name = 'five^2',
      id = '[3,4)'
  WHERE id = '[5,6)';
-- Update all partitions at once (each with leftovers)
SELECT * FROM temporal_partitioned ORDER BY id, valid_at;
  id   |        valid_at         |  name   
-------+-------------------------+---------
 [1,2) | [2000-01-01,2000-03-01) | one
 [1,2) | [2000-03-01,2000-04-01) | one^1
 [1,2) | [2000-04-01,2000-06-01) | one
 [1,2) | [2000-07-01,2010-01-01) | one
 [2,3) | [2000-06-01,2000-07-01) | three^2
 [3,4) | [2000-01-01,2000-03-01) | three
 [3,4) | [2000-03-01,2000-04-01) | three^1
 [3,4) | [2000-04-01,2000-06-01) | three
 [3,4) | [2000-06-01,2000-07-01) | five^2
 [3,4) | [2000-07-01,2010-01-01) | three
 [4,5) | [2000-06-01,2000-07-01) | one^2
 [5,6) | [2000-01-01,2000-03-01) | five
 [5,6) | [2000-03-01,2000-04-01) | five^1
 [5,6) | [2000-04-01,2000-06-01) | five
 [5,6) | [2000-07-01,2010-01-01) | five
(15 rows)

SELECT * FROM temporal_partitioned_1 ORDER BY id, valid_at;
  id   |        valid_at         |  name   
-------+-------------------------+---------
 [1,2) | [2000-01-01,2000-03-01) | one
 [1,2) | [2000-03-01,2000-04-01) | one^1
 [1,2) | [2000-04-01,2000-06-01) | one
 [1,2) | [2000-07-01,2010-01-01) | one
 [2,3) | [2000-06-01,2000-07-01) | three^2
(5 rows)

SELECT * FROM temporal_partitioned_3 ORDER BY id, valid_at;
  name   |  id   |        valid_at         
---------+-------+-------------------------
 three   | [3,4) | [2000-01-01,2000-03-01)
 three^1 | [3,4) | [2000-03-01,2000-04-01)
 three   | [3,4) | [2000-04-01,2000-06-01)
 five^2  | [3,4) | [2000-06-01,2000-07-01)
 three   | [3,4) | [2000-07-01,2010-01-01)
 one^2   | [4,5) | [2000-06-01,2000-07-01)
(6 rows)

SELECT * FROM temporal_partitioned_5 ORDER BY id, valid_at;
  name  |        valid_at         |  id   
--------+-------------------------+-------
 five   | [2000-01-01,2000-03-01) | [5,6)
 five^1 | [2000-03-01,2000-04-01) | [5,6)
 five   | [2000-04-01,2000-06-01) | [5,6)
 five   | [2000-07-01,2010-01-01) | [5,6)
(4 rows)

DROP TABLE temporal_partitioned;
RESET datestyle;
